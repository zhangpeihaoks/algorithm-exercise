//给你一个 m x n 的字符矩阵 box ，它表示一个箱子的侧视图。箱子的每一个格子可能为：
//
//
// '#' 表示石头
// '*' 表示固定的障碍物
// '.' 表示空位置
//
//
// 这个箱子被 顺时针旋转 90 度 ，由于重力原因，部分石头的位置会发生改变。每个石头会垂直掉落，直到它遇到障碍物，另一个石头或者箱子的底部。重力 不会 影
//响障碍物的位置，同时箱子旋转不会产生惯性 ，也就是说石头的水平位置不会发生改变。
//
// 题目保证初始时 box 中的石头要么在一个障碍物上，要么在另一个石头上，要么在箱子的底部。
//
// 请你返回一个 n x m的矩阵，表示按照上述旋转后，箱子内的结果。
//
//
//
// 示例 1：
//
//
//
// 输入：box = [["#",".","#"]]
//输出：[["."],
//      ["#"],
//      ["#"]]
//
//
// 示例 2：
//
//
//
// 输入：box = [["#",".","*","."],
//            ["#","#","*","."]]
//输出：[["#","."],
//      ["#","#"],
//      ["*","*"],
//      [".","."]]
//
//
// 示例 3：
//
//
//
// 输入：box = [["#","#","*",".","*","."],
//            ["#","#","#","*",".","."],
//            ["#","#","#",".","#","."]]
//输出：[[".","#","#"],
//      [".","#","#"],
//      ["#","#","*"],
//      ["#","*","."],
//      ["#",".","*"],
//      ["#",".","."]]
//
//
//
//
// 提示：
//
//
// m == box.length
// n == box[i].length
// 1 <= m, n <= 500
// box[i][j] 只可能是 '#' ，'*' 或者 '.' 。
//
//
// Related Topics 数组 双指针 矩阵 👍 18 👎 0

package main

// leetcode submit region begin(Prohibit modification and deletion)
func rotateTheBox(a [][]byte) [][]byte {
	n, m := len(a), len(a[0])
	ans := make([][]byte, m)
	for i := range ans {
		ans[i] = make([]byte, n)
		for j := range ans[i] {
			ans[i][j] = '.'
		}
	}
	for i, r := range a {
		for j := 0; j < m; j++ {
			c := 0
			// 注意这里 j 和外层循环的 j 是同一个变量，因此时间复杂度为 O(nm)
			for ; j < m && r[j] != '*'; j++ {
				if r[j] == '#' {
					c++
				}
			}
			if j < m {
				ans[j][n-1-i] = '*'
			}
			for k := j - 1; c > 0; k-- {
				ans[k][n-1-i] = '#'
				c--
			}
		}
	}
	return ans
}

//leetcode submit region end(Prohibit modification and deletion)
